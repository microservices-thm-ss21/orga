#!/bin/bash

# Created by argbash-init v2.6.1									Devenv Logic: |
# ARG_POSITIONAL_SINGLE([task])													  |
# ARGBASH_SET_DELIM([ ])														  |
# ARG_OPTION_STACKING([none])													  |
# ARG_RESTRICT_VALUES([none])													  V
# ARG_DEFAULTS_POS()
# ARG_HELP([<The general help message of my script>])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.6.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}


# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_task=
# THE DEFAULTS INITIALIZATION - OPTIONALS


	# clone)
	# 	clone_repositories
	# 	check_dependencies
	# 	init_modules
	# 	link_git_hooks
	# 	;;
	# update)
	# 	update_repositories
	# 	init_modules
	# 	link_git_hooks
	# 	;;
	# hook)
	# 	link_git_hooks
	# 	;;
	# check)
	# 	check_dependencies
	# 	init_modules
	# 	;;
	# run)
	# 	run_workspace
	# 	;;


    print_help ()
    {
       printf '%s\n' "Dieses Script soll alle möglichen wiederkehrenden Aufgaben bei der Entwicklung der Microservices übernehmen."
       printf 'Benutzung: %s [-h|--help] <task>\n' "$0"
       printf '\t%s\n' "-h,--help: Prints help"
       printf '\t%s\n' "<task> Werte:"
       printf '\t\t%s\n' "clone: Klont die dazugehörigen Repositories."
       printf '\t\t%s\n' "update: Bringt die vorhandenen Repositories auf den neuesten Stand."
   }

   parse_commandline ()
   {
       while test $# -gt 0
       do
          _key="$1"
          case "$_key" in
             -h|--help)
print_help
exit 0
;;
*)
_positionals+=("$1")
;;
esac
shift
done
}


handle_passed_args_count ()
{
	_required_args_string="'task'"
	test ${#_positionals[@]} -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${#_positionals[@]}." 1
	test ${#_positionals[@]} -le 1 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${#_positionals[@]} (the last one was: '${_positionals[*]: -1}')." 1
}

assign_positional_args ()
{
	_positional_names=('_arg_task' )

	for (( ii = 0; ii < ${#_positionals[@]}; ii++))
	do
		eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

######################################################################################################
######################################### Start of devenv.sh #########################################
######################################################################################################

# Git Repositories
ISSUE_SERVICE="git@git.thm.de:microservicesss21/issue-service.git"
PROJECT_SERVICE="git@git.thm.de:microservicesss21/project-service.git"
USER_SERVICE="git@git.thm.de:microservicesss21/user-service.git"
TEMPLATE_SERVICE="git@git.thm.de:microservicesss21/template-service.git"
# Verzeichnisse
ORGA_DIR="${pwd}"


# colorize output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' #"no color"

getDir() {
  echo "../$(echo $1 | sed 's/.*\///' | sed 's/\.git//')"
}

clone() {
  DIR="../$(echo $1 | sed 's/.*\///' | sed 's/\.git//')"
    echo "Hole $DIR von $1:";
    if [ -d "$DIR" ]; then
        printf "${YELLOW}Verzeichnis %s existiert. Überschreiben? [j/N] ${NC}" "$DIR";
        read -n 1 -r
        if [[ $REPLY =~ ^[JjYy]$ ]]; then
            rm -rf "$DIR";
        else
            exit 1;
        fi
    fi
    printf "\n\n"

    git clone "$1" "$DIR"

    printf "\n"

    if [ $? -ne 0 ]; then
        printf "${RED}Klonen fehlgeschlagen. Bist du berechtigt?${NC}\n";
        exit 1;
    else
        printf "${GREEN}Klonen von %s erfolgreich!${NC}\n\n" "$DIR";
    fi
}

clone_repositories() {
  clone $ISSUE_SERVICE
  clone $PROJECT_SERVICE
  clone $USER_SERVICE
  clone $TEMPLATE_SERVICE
} # end clone_repositories

update_repositories() {
  git pull
	cd  "../$(echo $ISSUE_SERVICE | sed 's/.*\///' | sed 's/\.git//')" && git pull && cd "$ORGA_DIR"
	cd  "../$(echo $PROJECT_SERVICE | sed 's/.*\///' | sed 's/\.git//')" && git pull && cd "$ORGA_DIR"
	cd  "../$(echo $USER_SERVICE | sed 's/.*\///' | sed 's/\.git//')" && git pull && cd "$ORGA_DIR"
	cd  "../$(echo $TEMPLATE_SERVICE | sed 's/.*\///' | sed 's/\.git//')" && git pull && cd "$ORGA_DIR"

}

# "Main Method:"

###############################################################################
echo '
  __  __ _____ _____ _____   ____   _____ ______ _______      _______ _____ ______  _____
 |  \/  |_   _/ ____|  __ \ / __ \ / ____|  ____|  __ \ \    / /_   _/ ____|  ____|/ ____|
 | \  / | | || |    | |__) | |  | | (___ | |__  | |__) \ \  / /  | || |    | |__  | (___
 | |\/| | | || |    |  _  /| |  | |\___ \|  __| |  _  / \ \/ /   | || |    |  __|  \___ \
 | |  | |_| || |____| | \ \| |__| |____) | |____| | \ \  \  /   _| || |____| |____ ____) |
 |_|  |_|_____\_____|_|  \_\\____/|_____/|______|_|  \_\  \/   |_____\_____|______|_____/

'
###############################################################################

printf "Value of '%s': %s\\n" 'task' "$_arg_task"

case $_arg_task in
	clone)
        clone_repositories
        ;;
    update)
        update_repositories
        ;;
		pull)
				update_repositories
				;;
    *)
        print_help
        ;;
esac
exit 0;

# ] <-- needed because of Argbash
